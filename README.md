# UART 协议解析器测试程序

本项目实现了一个UART协议解析器，并提供了C++测试程序和Python发送工具，用于通过Windows COM端口进行测试。

## 项目结构

- `parse_code.cpp` - 协议解析器核心代码
- `serial_port.h` / `serial_port.cpp` - Windows串口通信类
- `test_protocol.cpp` - C++测试程序
- `send_protocol.py` - Python发送工具
- `CMakeLists.txt` - CMake构建文件

## 开发环境搭建

### C++测试程序环境

1. **安装必要工具**
   - 安装 [Visual Studio](https://visualstudio.microsoft.com/downloads/) 或 [Visual Studio Code](https://code.visualstudio.com/)
   - 安装 [CMake](https://cmake.org/download/) (3.10或更高版本)
   - 安装 [MinGW](https://www.mingw-w64.org/downloads/) 或使用Visual Studio自带的MSVC编译器

2. **编译项目**

   使用CMake构建项目：

   ```bash
   # 创建构建目录
   mkdir build
   cd build

   # 使用CMake生成构建文件
   cmake ..

   # 编译项目
   cmake --build .
   ```

   编译完成后，可执行文件将位于 `build/bin` 目录下。

### Python发送工具环境

1. **安装Python**
   - 下载并安装 [Python](https://www.python.org/downloads/) (3.6或更高版本)

2. **安装依赖**
   ```bash
   pip install pyserial
   ```

## 硬件准备

测试需要以下硬件：

1. **USB转TTL串口模块**
   - 如CH340、CP2102、FT232等常见USB转TTL模块
   - 或者使用Arduino板作为USB-TTL转换器

2. **连接方式**
   - 将USB转TTL模块的TX和RX引脚连接起来形成环回，或者
   - 使用两个串口模块，分别连接到两台电脑，或者
   - 使用一个串口模块，在同一台电脑上同时运行C++测试程序和Python发送工具

## 测试过程

### 1. 运行C++测试程序

```bash
# 进入构建目录的bin子目录
cd build/bin

# 运行测试程序
./test_protocol
```

程序启动后，可以使用以下命令：

- `help` - 显示帮助信息
- `ports` - 列出可用串口
- `open COM1` - 打开指定串口（替换COM1为实际串口名）
- `baud 115200` - 设置波特率
- `debug on` - 开启调试模式
- `stats` - 显示协议统计信息
- `send info` - 发送信息类测试帧
- `send control` - 发送控制类测试帧
- `send param` - 发送参数类测试帧
- `send special` - 发送特殊类测试帧
- `speedtest <count> <size>` - 执行最大速率测试
- `errortest <type>` - 执行错误测试
- `exit` - 退出程序

### 2. 使用Python工具发送数据

```bash
# 列出可用串口
python send_protocol.py --list

# 发送信息类命令
python send_protocol.py --port COM2 --type info --subtype 1 --data "01 02 03"

# 发送控制类命令
python send_protocol.py --port COM2 --type control --subtype 1

# 发送多次数据
python send_protocol.py --port COM2 --type special --subtype 0 --data "48 65 6C 6C 6F" --count 5 --interval 0.5
```

## 协议说明

协议帧格式如下：

```
+--------+------+-----+-------+-----+------+------+-----+--------+
| 起始位 | 发送 | 接收 | 标志位 | 命令 | 长度 | 数据 | CRC | 结束位 |
| 0xAA   | 变长 | 变长 | 变长   | 1字节| 2字节| 变长 | 1字节| 0x55  |
+--------+------+-----+-------+-----+------+------+-----+--------+
```

- **起始位**: 固定为0xAA
- **发送方**: 发送设备ID，默认1字节
- **接收方**: 接收设备ID，默认1字节
- **标志位**: 协议标志，默认1字节
- **命令**: 命令字节，高2位表示命令类型，低6位表示子命令
- **长度**: 数据长度，小端序，2字节
- **数据**: 变长数据
- **CRC**: CRC-8校验值
- **结束位**: 固定为0x55

命令类型：
- 0: 信息类命令
- 1: 控制类命令
- 2: 参数类命令
- 3: 特殊类命令

## 实时查看统计信息

在C++测试程序中，可以通过以下方式查看统计信息：

1. 使用 `stats` 命令查看当前统计信息
2. 使用 `debug on` 命令开启调试模式，实时显示接收到的帧和错误信息
3. 使用 `reset` 命令重置统计信息

## 高级测试功能

### 最大速率测试

使用 `speedtest` 命令可以测试协议的最大传输速率：

```
speedtest <帧数量> <每帧数据大小>
```

例如：
- `speedtest 1000 64` - 发送1000个帧，每帧64字节数据
- `speedtest 500 1024` - 发送500个帧，每帧1024字节数据

测试完成后会显示以下统计信息：
- 发送的帧数量
- 总字节数
- 耗时
- 吞吐量（字节/秒）
- 帧率（帧/秒）

### 错误测试

使用 `errortest` 命令可以测试协议的错误处理能力：

```
errortest <错误类型>
```

支持的错误类型：
- `crc` - CRC校验错误测试
- `length` - 长度字段错误测试
- `invalid` - 无效帧测试
- `escape` - 转义序列错误测试
- `overflow` - 缓冲区溢出测试

例如：
- `errortest crc` - 发送一个CRC校验错误的帧
- `errortest length` - 发送一个长度字段与实际数据长度不符的帧

通过观察调试输出和统计信息，可以验证协议解析器对各种错误情况的处理能力。

## CRC计算错误分析与解决方案

在协议解析器实现中，发现了一个关键的CRC计算错误，导致接收方无法正确验证帧的完整性。以下是对这一问题的详细分析和解决方案：

### 错误产生原因

1. **CRC计算范围错误**：
   - 在解析接收到的帧时，`calculateFrameCRC()`函数错误地将接收到的CRC字段本身也包含在了CRC计算范围内
   - 而在发送帧时，`createFrame()`函数正确地在计算CRC值后才将CRC添加到帧中
   - 这导致了发送方和接收方使用不同的数据集计算CRC，必然导致验证失败

2. **转义处理顺序问题**：
   - 在`createFrame()`函数中，CRC是在原始数据上计算的，然后才进行转义处理
   - 而在解析时，`calculateFrameCRC()`函数是在已经解除转义的数据上计算CRC
   - 虽然这两种方法理论上应该产生相同的结果，但实际实现中存在不一致

3. **调试信息混乱**：
   - 调试输出中缺乏对CRC计算输入数据的清晰展示
   - 无法直观地比较发送方和接收方的CRC计算数据差异

### 解决方案

1. **统一CRC计算方法**：
   - 修改`calculateFrameCRC()`函数，确保其使用与`createFrame()`函数相同的数据字段和顺序
   - 排除接收到的CRC字段本身，只对帧的有效内容计算CRC
   - 确保CRC计算顺序为：发送方ID、接收方ID、标志位、命令字节、长度字段、数据字段

2. **重构帧生成逻辑**：
   - 在`createFrame()`函数中明确分离CRC计算和转义处理步骤
   - 先准备原始数据并计算CRC，然后再进行转义处理
   - 添加注释清晰说明CRC计算的范围和方法

3. **改进调试输出**：
   - 简化调试输出，只显示关键的CRC计算输入数据和结果
   - 在调试模式下，显示详细的CRC计算过程，便于排查问题

4. **修复转义处理**：
   - 确保`handleEscaping()`函数正确处理所有转义字符
   - 添加更清晰的注释，说明转义字符的处理逻辑

5. **长度字段解析修复**：
   - 修正长度字段的解析，确保正确处理转义字符
   - 确保长度字段与实际数据长度一致

通过以上修改，协议解析器现在能够正确计算和验证CRC，确保数据传输的完整性和可靠性。这些改进使得协议在高噪声环境下更加稳定，能够正确识别和处理损坏的数据帧。

## 常见问题

1. **串口打开失败**
   - 检查串口名称是否正确
   - 确认串口未被其他程序占用
   - 检查是否有足够权限访问串口

2. **数据接收异常**
   - 确认波特率设置正确
   - 检查硬件连接是否稳定
   - 检查发送的数据格式是否符合协议要求

3. **编译错误**
   - 确保安装了正确版本的编译器和依赖库
   - 检查CMake版本是否满足要求 

## 死锁问题分析与解决方案

在使用`speedtest`命令进行大数据量测试时，可能会遇到资源死锁问题，导致程序卡死或异常。以下是对这一问题的分析和解决方案：

### 死锁产生原因

1. **嵌套锁调用**：
   - 在`RingBuffer`类的方法中，存在互相调用的情况，例如`peek()`方法内部调用`available()`方法，而两者都使用了相同的互斥锁。
   - 在`resynchronize()`方法中，尝试在已经持有锁的情况下再次请求同一个锁，导致死锁。

2. **错误处理路径问题**：
   - 当检测到帧长度错误后，直接调用`resynchronize()`方法，但未先释放之前获取的锁。
   - 在处理转义序列错误时，同样存在锁释放顺序不当的问题。

3. **长时间持有锁**：
   - 在处理大量数据时，某些方法可能长时间持有锁，阻塞其他需要访问相同资源的操作。
   - 特别是在`findByte()`等需要遍历整个缓冲区的方法中，持有锁的时间与缓冲区大小成正比。

4. **递归锁问题**：
   - 当处理大数据包（如10000字节）时，可能触发多层嵌套的锁请求，增加了死锁风险。

### 解决方案

1. **最小化锁定范围**：
   - 修改`RingBuffer`类的方法，确保锁的范围最小化，只在必要的操作上加锁。
   - 在`peek()`方法中直接计算可用数据量，而不是调用`available()`方法，避免嵌套锁。

2. **使用数据快照**：
   - 在需要遍历或搜索缓冲区的方法中（如`findByte()`），先创建数据快照，然后在不持有锁的情况下处理数据。
   - 例如，在`resynchronize()`方法中，先获取缓冲区数据的副本，然后释放锁，再进行处理。

3. **正确的错误处理顺序**：
   - 在所有错误处理路径中，确保先调用`resetParser()`释放资源，再调用`resynchronize()`。
   - 修改了`PARSE_LEN`、`PARSE_DATA`、`PARSE_CRC`等状态下的错误处理逻辑。

4. **避免递归锁**：
   - 重构了`available()`和`peek()`等方法，避免它们之间的相互调用。
   - 在`findByte()`方法中，先获取数据快照，然后在不持有锁的情况下进行搜索。

5. **提前释放资源**：
   - 在进行耗时操作前，确保先释放所有锁，特别是在处理大数据包时。
   - 在`resynchronize()`方法中，先调用`resetParser()`重置解析器状态，再进行缓冲区操作。

通过以上优化，有效解决了在大数据量传输时出现的死锁问题，提高了协议解析器的稳定性和可靠性。 